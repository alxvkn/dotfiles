#!/bin/sh

# pactl -f json list sinks | jq '.[] | select(.index == 45) | .properties["alsa.long_card_name"]'

sink_active_port_type() {
    JSON="$(pactl -f json list sinks 2>/dev/null)"
    echo $JSON | jq -r -c '.[] | select(.name == "'"$1"'") | .active_port as $active_port | .ports[] | select(.name == $active_port) | .type'
}

sink_device_api() {
    JSON="$(pactl -f json list sinks 2>/dev/null)"
    # echo $JSON | jq -r '.[] | select(.properties."device.api" == "bluez5")'
    echo $JSON | jq -r '.[] | select(.name == "'"$1"'") | .properties."device.api"'
}

default_sink_muted() {
    # pactl -f json list sinks 2>/dev/null | jq '.[] | select(.name == "'"$1"'") | .mute' |
    #     { read bool; [ $bool = 'true' ]; }
    # funny how they actually have this command
    pactl get-sink-mute @DEFAULT_SINK@ |
        { read mute; [ "$mute" = 'Mute: yes' ]; }
}

default_source_muted() {
    pactl get-source-mute @DEFAULT_SOURCE@ |
        { read mute; [ "$mute" = 'Mute: yes' ]; }
}

sink_index_by_name() {
    pactl -f json list sinks 2>/dev/null | jq '.[] | select(.name == "'"$1"'") | .index'
}

on_update() {
    # !!! volume shown is for left channel
    case "$(sink_active_port_type $(pactl get-default-sink))" in
        HDMI)
            sink_icon_unmuted=󰽟
            sink_icon_muted=󰽠
            ;;
        Headphones)
            sink_icon_unmuted=󰋋
            sink_icon_muted=󰟎
            ;;
        *)
            sink_icon_unmuted=󰕾
            sink_icon_muted=󰝟
            ;;
    esac

    source_icon_unmuted=󰍬
    source_icon_muted=󰍭

    if [ "$(sink_device_api $(pactl get-default-sink))" = bluez5 ]; then
        battery_percentage="$(bluetoothctl info | grep 'Battery Percentage' | sed 's/.*(\(.*\))/\1/')"
        icon_api="󰥉 $battery_percentage%"
    else
        icon_api=
    fi

    if default_sink_muted; then
        sink_icon="$sink_icon_muted"
        sink_volume=
    else
        sink_icon="$sink_icon_unmuted"
        sink_volume=$(pactl get-sink-volume @DEFAULT_SINK@ | awk 'NR==1{ print $5 }')
    fi

    if default_source_muted; then
        source_icon="$source_icon_muted"
        source_volume=
    else
        source_icon="$source_icon_unmuted"
        source_volume=$(pactl get-source-volume @DEFAULT_SOURCE@ | awk 'NR==1{ print $5 }')
    fi

    if [ -n "$(pactl list source-outputs)" ]; then
        source_icon="<span color='#fc9526'>$source_icon</span>"
    fi

    echo '{"full_text":"'$icon_api $sink_icon "$sink_volume" $source_icon "$source_volume"'"}'
}

# pactl json output is fucked up
# at least with jq (maybe it expects a newline before each new object)
pactl subscribe |
    stdbuf -o0 grep -e "on sink #" -e "on source #" -e "on source-output #" -e "on server #" |
    while read void
    do
        on_update
    done &

on_update

jq --unbuffered -c '.' | while read object
do
    echo $object
    button="$(echo $object | jq -r '.button')"

    # https://github.com/swaywm/sway/issues/5571
    case $button in
        1) pactl set-sink-mute 0 toggle
            ;;
        2)
            (if pgrep -f tui_mixer; then
            pkill -f tui_mixer
        else
            footclient --app-id=tui_mixer pulsemixer &
            fi) 2>&1 >/dev/null
            ;;
        3) pactl set-source-mute 0 toggle
            ;;
        4) pactl set-sink-volume 0 +5%
            ;;
        5) pactl set-sink-volume 0 -5%
            ;;
    esac
done
